// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package generated

import (
	"context"

	"github.com/google/uuid"
)

const findExecutionByUUID = `-- name: FindExecutionByUUID :one
SELECT id, uuid, workflow_name, state, created_at, updated_at
FROM sagas.executions
WHERE uuid = $1 LIMIT 1
`

func (q *Queries) FindExecutionByUUID(ctx context.Context, argUuid uuid.UUID) (SagasExecution, error) {
	row := q.db.QueryRow(ctx, findExecutionByUUID, argUuid)
	var i SagasExecution
	err := row.Scan(
		&i.Identifier,
		&i.Uuid,
		&i.WorkflowName,
		&i.State,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertExecution = `-- name: InsertExecution :exec
INSERT INTO sagas.executions
	("uuid", workflow_name, state, created_at, updated_at)
VALUES ($1, $2, $3, now(), now()) RETURNING id
`

type InsertExecutionParams struct {
	Uuid         uuid.UUID
	WorkflowName string
	State        []byte
}

func (q *Queries) InsertExecution(ctx context.Context, arg InsertExecutionParams) error {
	_, err := q.db.Exec(ctx, insertExecution, arg.Uuid, arg.WorkflowName, arg.State)
	return err
}

const updateExecution = `-- name: UpdateExecution :exec
UPDATE sagas.executions
SET state = $2, updated_at = now()
WHERE uuid = $1
`

type UpdateExecutionParams struct {
	Uuid  uuid.UUID
	State []byte
}

func (q *Queries) UpdateExecution(ctx context.Context, arg UpdateExecutionParams) error {
	_, err := q.db.Exec(ctx, updateExecution, arg.Uuid, arg.State)
	return err
}
